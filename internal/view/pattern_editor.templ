package view

import "github.com/msomdec/stitch-map-2/internal/domain"
import "github.com/msomdec/stitch-map-2/internal/service"
import "strconv"
import "fmt"

templ PatternEditorPage(displayName string, pattern *domain.Pattern, stitches []domain.Stitch, groupImages map[int64][]domain.PatternImage, psToLibrary map[int64]int64, errMsg string) {
	@Layout(editorTitle(pattern), displayName) {
		if errMsg != "" {
			<div class="notification is-danger">
				{ errMsg }
			</div>
		}
		<form id="pattern-form" method="POST" action={ editorAction(pattern) }>
			<h1 class="title">{ editorTitle(pattern) }</h1>
			<!-- Pattern Metadata -->
			<div class="box">
				<p class="help has-text-grey mb-3">Fields marked <span class="has-text-danger">*</span> are required</p>
				<div class="columns">
					<div class="column is-5">
						<div class="field">
							<label class="label" for="name">
								Pattern Name <span class="has-text-danger" aria-label="required">*</span>
							</label>
							<div class="control">
								<input class="input" type="text" id="name" name="name" required
									value={ patternFieldValue(pattern, "name") }
									placeholder="e.g., Amigurumi Bear"/>
							</div>
						</div>
					</div>
					<div class="column is-2">
						<div class="field">
							<label class="label" for="pattern_type">
								Type <span class="has-text-danger" aria-label="required">*</span>
							</label>
							<div class="control">
								<div class="select is-fullwidth">
									<select id="pattern_type" name="pattern_type">
										<option value="round"
											if pattern == nil || pattern.PatternType == domain.PatternTypeRound { selected }>Round</option>
										<option value="row"
											if pattern != nil && pattern.PatternType == domain.PatternTypeRow { selected }>Row</option>
									</select>
								</div>
							</div>
						</div>
					</div>
					<div class="column is-2">
						<div class="field">
							<label class="label" for="difficulty">
								Difficulty <span class="has-text-grey is-size-7">(optional)</span>
							</label>
							<div class="control">
								<div class="select is-fullwidth">
									<select id="difficulty" name="difficulty">
										<option value=""
											if pattern == nil || pattern.Difficulty == "" { selected }>-- Select --</option>
										<option value="Beginner"
											if pattern != nil && pattern.Difficulty == "Beginner" { selected }>Beginner</option>
										<option value="Intermediate"
											if pattern != nil && pattern.Difficulty == "Intermediate" { selected }>Intermediate</option>
										<option value="Advanced"
											if pattern != nil && pattern.Difficulty == "Advanced" { selected }>Advanced</option>
										<option value="Expert"
											if pattern != nil && pattern.Difficulty == "Expert" { selected }>Expert</option>
									</select>
								</div>
							</div>
						</div>
					</div>
					<div class="column is-3">
						<div class="field">
							<label class="label" for="hook_size">
								Hook Size <span class="has-text-grey is-size-7">(optional)</span>
							</label>
							<div class="control">
								<input class="input" type="text" id="hook_size" name="hook_size"
									value={ patternFieldValue(pattern, "hook_size") }
									placeholder="e.g., 5.0mm"/>
							</div>
						</div>
					</div>
				</div>
				<div class="columns">
					<div class="column is-7">
						<div class="field">
							<label class="label" for="description">
								Description <span class="has-text-grey is-size-7">(optional)</span>
							</label>
							<div class="control">
								<textarea class="textarea" id="description" name="description"
									placeholder="Brief description of the pattern">{ patternFieldValue(pattern, "description") }</textarea>
							</div>
						</div>
					</div>
					<div class="column is-5">
						<div class="field">
							<label class="label" for="yarn_weight">
								Yarn Weight <span class="has-text-grey is-size-7">(optional)</span>
							</label>
							<div class="control">
								<input class="input" type="text" id="yarn_weight" name="yarn_weight"
									value={ patternFieldValue(pattern, "yarn_weight") }
									placeholder="e.g., Worsted"/>
							</div>
						</div>
					</div>
				</div>
			</div>
			<!-- Pattern Parts -->
			<h2 class="title is-4">Pattern Overview</h2>
			<div data-signals={ fmt.Sprintf("{nextidx: %d}", editorNextSignalIndex(pattern)) }>
				<div id="pattern-parts">
					if pattern != nil && len(pattern.InstructionGroups) > 0 {
						for gi, g := range pattern.InstructionGroups {
							@groupFields(gi, g, stitches, pattern.ID, groupImages[g.ID], psToLibrary)
						}
					} else {
						@groupFields(0, domain.InstructionGroup{Label: "Round 1", RepeatCount: 1}, stitches, 0, nil, nil)
					}
				</div>
				<!-- Add Part Button -->
				<div class="mb-5">
					<button
						type="button"
						class="button is-primary is-outlined"
						data-on:click="@post('/patterns/editor/add-part?gi=' + $nextidx); $nextidx = $nextidx + 1"
					>
						+ Add Part
					</button>
				</div>
			</div>
			<!-- Submit -->
			<div class="field is-grouped" data-signals="{showSave: false, showPreview: false, showCancel: false}">
				<div class="control">
					<button class="button is-primary" type="button" data-on:click="$showSave = true">Save Pattern</button>
				</div>
				<div class="control">
					<button type="button" class="button is-info" data-on:click="$showPreview = true">Preview</button>
				</div>
				<div class="control">
					<button type="button" class="button is-light" data-on:click="$showCancel = true">Cancel</button>
				</div>
			</div>
		</form>
		<!-- Save Confirmation Modal -->
		<div id="save-modal" class="modal" data-class:is-active="$showSave">
			<div class="modal-background" data-on:click="$showSave = false"></div>
			<div class="modal-card">
				<header class="modal-card-head">
					<p class="modal-card-title">Save Pattern</p>
					<button class="delete" aria-label="close" type="button" data-on:click="$showSave = false"></button>
				</header>
				<section class="modal-card-body">
					Save changes to this pattern?
				</section>
				<footer class="modal-card-foot">
					<button class="button is-primary" type="button" onclick="var f=document.getElementById('pattern-form');if(f.reportValidity()){window.__formSubmitting=true;f.submit();}">Save</button>
					<button class="button" type="button" data-on:click="$showSave = false">Cancel</button>
				</footer>
			</div>
		</div>
		<!-- Cancel Confirmation Modal -->
		<div id="cancel-modal" class="modal" data-class:is-active="$showCancel">
			<div class="modal-background" data-on:click="$showCancel = false"></div>
			<div class="modal-card">
				<header class="modal-card-head">
					<p class="modal-card-title">Discard Changes</p>
					<button class="delete" aria-label="close" type="button" data-on:click="$showCancel = false"></button>
				</header>
				<section class="modal-card-body">
					Discard unsaved changes?
				</section>
				<footer class="modal-card-foot">
					<button class="button is-danger" type="button" onclick="window.__formSubmitting=true;window.location.href='/patterns'">Discard</button>
					<button class="button" type="button" data-on:click="$showCancel = false">Keep Editing</button>
				</footer>
			</div>
		</div>
		<!-- Preview Modal -->
		<div id="preview-modal" class="modal" data-class:is-active="$showPreview">
			<div class="modal-background" data-on:click="$showPreview = false"></div>
			<div class="modal-content">
				<div class="box">
					<h2 class="title is-5">Pattern Preview</h2>
					if pattern != nil && len(pattern.InstructionGroups) > 0 {
						<pre class="pattern-text">{ service.RenderPatternText(pattern) }</pre>
						<p class="help has-text-grey mt-2">
							{ strconv.Itoa(service.StitchCount(pattern)) + " stitches total" }
						</p>
					} else {
						<p class="has-text-grey">Save your pattern first to see a preview.</p>
					}
				</div>
			</div>
			<button class="modal-close is-large" aria-label="close" type="button" data-on:click="$showPreview = false"></button>
		</div>
		<!-- beforeunload protection -->
		<script>
			window.__formSubmitting = false;
			window.addEventListener('beforeunload', function(e) {
				if (!window.__formSubmitting) {
					e.preventDefault();
				}
			});
		</script>
	}
}

templ groupFields(gi int, g domain.InstructionGroup, stitches []domain.Stitch, patternID int64, images []domain.PatternImage, psToLibrary map[int64]int64) {
	<div class="box is-relative" id={ "part-" + strconv.Itoa(gi) }>
		<button
			type="button"
			class="button is-danger is-outlined is-small remove-part-btn box-close-btn"
			title="Remove part"
			onclick={ removePartOnclick(strconv.Itoa(gi)) }
		>
			&times;
		</button>
		<div class="columns">
			<div class="column is-5">
				<div class="field">
					<label class="label">
						Part Name <span class="has-text-danger" aria-label="required">*</span>
					</label>
					<div class="control">
						<input class="input" type="text" name={ "group_label_" + strconv.Itoa(gi) }
							value={ g.Label } required placeholder="e.g., Brim, Body, Round 1"/>
					</div>
				</div>
			</div>
			<div class="column is-2">
				<div class="field">
					<label class="label">
						Quantity <span class="has-text-danger" aria-label="required">*</span>
					</label>
					<div class="control">
						<input class="input" type="number" name={ "group_repeat_" + strconv.Itoa(gi) }
							value={ strconv.Itoa(maxInt(g.RepeatCount, 1)) } min="1"/>
					</div>
				</div>
			</div>
			<div class="column is-5">
				<div class="field">
					<label class="label">
						Notes <span class="has-text-grey is-size-7">(optional)</span>
					</label>
					<div class="control">
						<input class="input" type="text" name={ "group_notes_" + strconv.Itoa(gi) }
							value={ g.Notes } placeholder="Notes for this part"/>
					</div>
				</div>
			</div>
		</div>
		<h3 class="subtitle is-6">Stitches</h3>
		<!-- Entry column headers -->
		<div class="columns is-vcentered mb-0 is-size-7 has-text-grey">
			<div class="column is-5">Stitch <span class="has-text-danger" aria-label="required">*</span></div>
			<div class="column is-2">Count <span class="has-text-danger" aria-label="required">*</span></div>
			<div class="column is-2">Repeat <span class="has-text-danger" aria-label="required">*</span></div>
			<div class="column is-1"></div>
		</div>
		<div id={ "entries-" + strconv.Itoa(gi) }>
			if len(g.StitchEntries) > 0 {
				for ei, e := range g.StitchEntries {
					@entryFields(gi, ei, e, stitches, psToLibrary)
				}
			} else {
				@entryFields(gi, 0, domain.StitchEntry{Count: 1, RepeatCount: 1}, stitches, nil)
			}
		</div>
		<button
			type="button"
			class="button is-small is-primary is-outlined mt-2"
			data-on:click={ fmt.Sprintf("@post('/patterns/editor/add-entry/%d?ei=' + $nextidx); $nextidx = $nextidx + 1", gi) }
		>
			+ Add Stitch
		</button>
		if patternID > 0 && g.ID > 0 {
			<hr/>
			<h3 class="subtitle is-6">Images</h3>
			<div id={ "images-" + strconv.Itoa(gi) }>
				@ImageSection(patternID, gi, g.ID, images)
			</div>
		}
	</div>
}

// GroupFieldsFragment is the exported version of groupFields for use by SSE handlers.
templ GroupFieldsFragment(gi int, g domain.InstructionGroup, stitches []domain.Stitch) {
	@groupFields(gi, g, stitches, 0, nil, nil)
}

templ entryFields(gi int, ei int, e domain.StitchEntry, stitches []domain.Stitch, psToLibrary map[int64]int64) {
	<div class="columns is-vcentered mb-0" id={ "entry-" + strconv.Itoa(gi) + "-" + strconv.Itoa(ei) }>
		<div class="column is-5">
			<div class="field">
				<div class="control">
					<div class="select is-fullwidth">
						<select name={ "entry_stitch_" + strconv.Itoa(gi) + "_" + strconv.Itoa(ei) } required>
							<option value="">Select stitch</option>
							for _, s := range stitches {
								<option value={ strconv.FormatInt(s.ID, 10) }
									if isStitchSelected(s.ID, e.PatternStitchID, psToLibrary) { selected }>{ s.Abbreviation } - { s.Name }</option>
							}
						</select>
					</div>
				</div>
			</div>
		</div>
		<div class="column is-2">
			<div class="field">
				<div class="control">
					<input class="input" type="number" name={ "entry_count_" + strconv.Itoa(gi) + "_" + strconv.Itoa(ei) }
						value={ strconv.Itoa(maxInt(e.Count, 1)) } min="1" title="Count"/>
				</div>
			</div>
		</div>
		<div class="column is-2">
			<div class="field">
				<div class="control">
					<input class="input" type="number" name={ "entry_repeat_" + strconv.Itoa(gi) + "_" + strconv.Itoa(ei) }
						value={ strconv.Itoa(maxInt(e.RepeatCount, 1)) } min="1" title="Repeat"/>
				</div>
			</div>
		</div>
		<div class="column is-1">
			<button
				type="button"
				class="button is-danger is-outlined is-small remove-entry-btn"
				title="Remove stitch"
				onclick={ removeEntryOnclick("entry-" + strconv.Itoa(gi) + "-" + strconv.Itoa(ei)) }
			>
				&times;
			</button>
		</div>
	</div>
}

// EntryFieldsFragment is the exported version of entryFields for use by SSE handlers.
templ EntryFieldsFragment(gi int, ei int, e domain.StitchEntry, stitches []domain.Stitch, psToLibrary map[int64]int64) {
	@entryFields(gi, ei, e, stitches, psToLibrary)
}

// isStitchSelected determines if a library stitch should be pre-selected for an entry.
// When psToLibrary is provided (editing existing pattern), it maps PatternStitchID -> LibraryStitchID.
// When psToLibrary is nil (new entries or form resubmission), PatternStitchID holds the library stitch ID directly.
func isStitchSelected(libraryStitchID int64, entryPatternStitchID int64, psToLibrary map[int64]int64) bool {
	if entryPatternStitchID == 0 {
		return false
	}
	if psToLibrary != nil {
		libID, ok := psToLibrary[entryPatternStitchID]
		if !ok {
			return false
		}
		return libID == libraryStitchID
	}
	// No psToLibrary: PatternStitchID is already a library stitch ID (form submission or new pattern).
	return entryPatternStitchID == libraryStitchID
}

func editorTitle(pattern *domain.Pattern) string {
	if pattern == nil || pattern.ID == 0 {
		return "New Pattern"
	}
	return "Edit Pattern"
}

func editorAction(pattern *domain.Pattern) templ.SafeURL {
	if pattern == nil || pattern.ID == 0 {
		return "/patterns"
	}
	return templ.SafeURL("/patterns/" + strconv.FormatInt(pattern.ID, 10) + "/edit")
}

func patternFieldValue(pattern *domain.Pattern, field string) string {
	if pattern == nil {
		return ""
	}
	switch field {
	case "name":
		return pattern.Name
	case "description":
		return pattern.Description
	case "hook_size":
		return pattern.HookSize
	case "yarn_weight":
		return pattern.YarnWeight
	case "difficulty":
		return pattern.Difficulty
	default:
		return ""
	}
}

func maxInt(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func intPtrStr(p *int) string {
	if p == nil {
		return ""
	}
	return strconv.Itoa(*p)
}

// derivedExpectedCount computes the expected stitch count for a group
// based on its stitch entries and repeat count.
func derivedExpectedCount(g domain.InstructionGroup) int {
	return service.GroupStitchCount(&g) * g.RepeatCount
}

// editorNextSignalIndex returns a starting index for the $nextidx Datastar signal.
// Uses a high offset to avoid collisions with server-rendered indices (0, 1, 2...).
func editorNextSignalIndex(pattern *domain.Pattern) int {
	maxIdx := 0
	if pattern != nil {
		for gi, g := range pattern.InstructionGroups {
			if gi > maxIdx {
				maxIdx = gi
			}
			for ei := range g.StitchEntries {
				if ei > maxIdx {
					maxIdx = ei
				}
			}
		}
	}
	return maxIdx + 100
}

script removePartOnclick(partID string) {
	if (confirm('Remove this part and all its stitches?')) {
		document.getElementById('part-' + partID).remove();
	}
}

script removeEntryOnclick(entryID string) {
	if (confirm('Remove this stitch entry?')) {
		document.getElementById(entryID).remove();
	}
}
